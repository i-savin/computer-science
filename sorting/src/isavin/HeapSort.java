package isavin;


/**
 * Реализация сортировки с использованием кучи.
 * Куча представляет собой абстрактную структуру данных типа двоичного дерева.
 * Основное правило кучи <b>a[child] &le; a[parent]</b>
 * 
 * @author isavin 
 *
 */
public class HeapSort {
	private static int heapSize;
	
	/**
	 * Сортировка входного массива с использованием кучи. Сначала происходит
	 * формирование кучи.
	 * После этого в корне кучи находится максимальный элемент. Его нужно
	 * поменять местами с последним элементом и удалить из кучи (уменьшить
	 * размер кучи на 1). Теперь нужно перестроить кучу так, чтобы выполнялось
	 * основное правило кучи - a[child] &le; a[parent], которое возможно было
	 * нарушено во время предыдущей операции.
	 * Теперь в куче находится максимальный из оставшихся элементов. Эту 
	 * операцию нужно повторить до тех пор, пока в куче не останется 1 элемент.
	 * 
	 * @param a исходный массив
	 * 
	 * @see #buildHeap(int[])
	 * @see #heapify(int[], int)
	 */
	public static void sort(int[] a) {
		Main.comparing = 0;
		Main.swaping = 0;
		
		heapSize = a.length;
		buildHeap(a);
		while (heapSize > 1) {
			swap(a, 0, heapSize - 1);
			heapSize--;
			heapify(a, 0);
		}
		
	}
	
	/**
	 * Формирование кучи. Элементы с индексами начиная с a.length / 2 + 1 - это
	 * листь дерева. Для всех остальных элементов нужно произвести операцию 
	 * переупорядочивания, так чтобы выполнялось основное правило кучи:
	 * a[child] &le; a[parent]
	 * 
	 * @param a исходный массив
	 * @see #heapify(int[], int)
	 */
	private static void buildHeap(int[] a) {
		for (int i = a.length / 2; i >= 0; i--) {
			heapify(a, i);
		}
	}
	
	/**
	 * Переупорядочивание элементов поддерева таким образом, чтобы выполнялось 
	 * основное правило кучи a[child] &le; a[parent]. Элемент, находящийся в
	 * корне поддерева, сравнивается со своим левым и правым потомками. Если
	 * один из них больше корня, они меняются местами (если оба больше, 
	 * меняются с максимальным). После этого процедура вызывается рекурсивно
	 * для поддерева, корень которого - максимальный на предыдущем этапе
	 * индекс элемента.
	 *  
	 * @param a исходный массив
	 * @param i корень поддерева, элементы которого нужно упорядочить
	 * 
	 * @see #left(int)
	 * @see #right(int)
	 * @see #swap(int[], int, int)
	 */
	private static void heapify(int[] a, int i) {
		int l = left(i);
		int r = right(i);
		int largest = i;
		if (l < heapSize && a[i] < a[l]) {
			largest = l;
		}
		if (r < heapSize && a[largest] < a[r]) {
			largest = r;
		}
		if (largest != i) {
			swap(a, i, largest);
			heapify(a, largest);
		}
	}

	/**
	 * Получение индекс левого потомка заданного элемента
	 * @param i индекс элемента, для которого нужно получить левого потомка
	 * @return индекс левого потомка
	 */
	private static int left(int i) {
		return 2 * i + 1;
	}

	/**
	 * Получение индекс правого потомка заданного элемента
	 * @param i индекс элемента, для которого нужно получить правого потомка
	 * @return индекс правого потомка
	 */	
	private static int right(int i) {
		return 2 * i + 2;
	}
	
	/**
	 * Меняет местами два элемента в массиве
	 * 
	 * @param a массив
	 * @param i индекс первого элемента
	 * @param j индекс второго элемента
	 */
	private static void swap(int[] a, int i, int j) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
}
